# 3. Dicee

진행 상태: 시작 전
날짜: 2025/10/09 오후 11:59 (GMT+9) → 2025/10/15 오전 12:01 (GMT+9)
주차: 3주차

# 51

## 확장

- 확장 클래스를 활용하기 위해서, **`행의 자식`**이거나 **`열의 자식`**이어야 함.
  - 주축의 공간을 하위아이템은 채우기 위해서 팽창하게 된다.
- 다른 확장 위젯에 비해 공간을 얼마나 차지할지를 구분할 수 있다.
  - 같은 확장 위젯이 아무 제약 없이 존재하면, 동등하게 파이를 나눠가진다.
  - flex를 통해서 원하는 비율로 조정이 가능하다. (기본값은 1)

## 이미지 축약 코드 작성

- **`child: Image(image: AssetImage(’images/dice1.png’)` → `child: Image.asset('images/dice1.png')`**
  - 표준 이미지 위젯 활용 방식 외에 간결하게 축약해서 작성할 수 있다.

---

# 52

## 주사위 앱(Dicee) 예제

- Flutter의 **StatefulWidget**을 활용한 대표적인 예제.
- **Random 클래스**를 이용해 주사위 눈(1~6)을 무작위로 생성하고, 버튼을 클릭할 때마다 UI가 새로 그려지도록 구성함.

### 주요 포인트

- `import 'dart:math';`
  → 외부 라이브러리 **dart:math**에서 `Random()` 클래스를 불러옴.
- `setState()`
  → 내부 변수(`leftDiceNumber`, `rightDiceNumber`)가 바뀌면 **UI를 다시 빌드**하도록 트리거함.
- `Expanded` 위젯
  → Row의 자식으로 사용되어 **주사위 이미지가 화면을 균등하게 차지**하도록 함.

### 예시 코드

```dart
import 'package:flutter/material.dart';
import 'dart:math';

void main() {
  runApp(
    MaterialApp(
      debugShowCheckedModeBanner: false,
      home: Scaffold(
        backgroundColor: Colors.cyan[900],
        appBar: AppBar(
          centerTitle: true,
          title: const Text(
            'SongHaEun [ Dicee ]',
            style: TextStyle(color: Colors.white),
          ),
          backgroundColor: Colors.cyan[900],
        ),
        body: DicePage(),
      ),
    ),
  );
}

class DicePage extends StatefulWidget {
  const DicePage({super.key});

  @override
  State<DicePage> createState() => _DicePageState();
}

class _DicePageState extends State<DicePage> {
  int leftDiceNumber = 1;
  int rightDiceNumber = 1;
  Random random = Random();

  @override
  Widget build(BuildContext context) {
    // build 안에 있어야, 제대로 변수가 변경된다. -> 핫 리로드 할 때는 build 안의 값만 바뀜. -> statelessWidget에 있을 때는

    return Center(
      child: Row(
        children: <Widget>[
          Expanded(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: TextButton(
                onPressed: () {
                  setState(() {
                    leftDiceNumber = random.nextInt(6) + 1;
                  });
                },
                child: Image.asset('images/dice$leftDiceNumber.png'),
              ),
            ),
          ),
          Expanded(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: TextButton(
                onPressed: () {
                  setState(() {
                    rightDiceNumber = random.nextInt(6) + 1;
                  });
                },
                child: Image.asset('images/dice$rightDiceNumber.png'),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

---

# 53

## Random 클래스 (dart:math)

- \*난수(Random number)\*\*를 생성할 때 사용하는 클래스.
- dart의 기본 라이브러리 중 하나로, **정수(int)**, **실수(double)**, **불리언(bool)** 형태의 난수를 만들 수 있다.
- 코드 상단에 `import 'dart:math';` 를 추가해야 사용 가능하다.

### 예시 코드

```dart
var intValue = Random().nextInt(10);   // 0~9 사이의 정수
int intValue2 = Random().nextInt(10) + 1   // 1~10 사이의 정수
var doubleValue = Random().nextDouble(); // 0~1 사이의 실수
var boolValue = Random().nextBool();   // true / false

```

→ 위 예시처럼, Random() 객체를 생성한 뒤 `.nextInt()`, `.nextDouble()`, `.nextBool()`을 호출하여 난수를 만든다.

---

# 54

## StatelessWidget vs StatefulWidget

> Flutter에서는 상태(State) 관리가 핵심으로,
>
> 사용자의 행동이나 외부 요인에 따라 UI가 바뀌는 경우 상태 추적이 필요하다.

| 구분                     | StatelessWidget                     | StatefulWidget                        |
| ------------------------ | ----------------------------------- | ------------------------------------- |
| **상태(State)**          | 없음 (한 번 그려지면 고정됨)        | 있음 (상태 변화에 따라 다시 빌드됨)   |
| **변경 가능성**          | 변하지 않음                         | `setState()`로 변경 가능              |
| **생명 주기(Lifecycle)** | `build()`만 존재                    | `initState()`, `dispose()` 등 다양함  |
| **사용 목적**            | 고정된 UI (로고, 단순 텍스트 등)    | 사용자 입력이나 이벤트에 반응하는 UI  |
| **업데이트 방식**        | 위젯이 재생성되지 않는 한 변경 없음 | `setState()` 호출 시 UI 자동 업데이트 |

---

# 55

## setState()의 역할

- `StatefulWidget`의 **핵심 메서드**로, 내부 상태(State)를 변경하고 Flutter에게 **UI를 다시 그려달라고 요청**한다.

### 예시 코드

```dart
setState(() {
  leftDiceNumber = Random().nextInt(6) + 1;
  rightDiceNumber = Random().nextInt(6) + 1;
});

```

- **setState() 내부**에서 변경한 변수들이 반영되어 `build()` 메서드가 **자동으로 다시 실행**된다.
- 주로 버튼 클릭, 체크박스 선택 등 **이벤트(onPressed 등)**와 함께 사용한다.

---

# 56

## 상태 관리의 필요성

- 예시:
  - **인스타그램**에서 게시물에 ‘좋아요’를 누르면, 하트 아이콘의 색상이 즉시 변하고 좋아요 수가 증가함.
  - **배달의민족**에서 주문 상태가 ‘조리 중 → 배달 중 → 배달 완료’로 바뀌면, 주문 내역 화면이 자동으로 갱신됨.
  - **유튜브**에서 영상 재생 중 ‘좋아요’나 ‘구독’을 누르면, 버튼 색상과 구독자 수가 즉시 반영됨.
- 이런 UI의 동적 변화가 바로 **상태(State)**의 변화이며, Flutter는 이 변화를 감지해 **자동으로 위젯을 리빌드(build)** 한다.

---

# 57

## StatelessWidget을 무조건 Stateful로 대체하지 않는 이유

- 모든 위젯을 Stateful로 만들면 **성능과 관리 비용이 증가**한다.
- **`Stateless`**는
  - 불필요한 `setState()` 호출이 없고,
  - 생명주기 관리(initState/dispose)가 필요 없으며,
  - 유지보수가 용이하다.
- 상태 변화가 **정말 필요한 곳에만** StatefulWidget을 사용해야 한다.

---

# 58

## 생명주기(Lifecycle)

- Flutter 앱은 아래 순서로 실행된다.
  1. **Compile (컴파일)** → 고급 언어를 기계어로 변환
  2. **Build (빌드)** → 실행 가능한 파일로 패키징
  3. **Runtime (런타임)** → 사용자가 실제 앱을 실행하는 단계
- Flutter SDK의 **bin 폴더 경로**를 지정하는 이유도,
  이 실행 바이너리(binary)가 컴파일 및 빌드 과정을 수행하기 때문이다.

---

# 59

## StatefulWidget의 동작 흐름

1. 사용자가 버튼을 클릭하거나, 데이터가 변경됨
2. `setState()`가 호출되어 내부 상태가 변경됨
3. Flutter 프레임워크가 **해당 위젯의 build() 메서드를 다시 호출**
4. 새로운 상태에 맞게 UI를 다시 그림(Rebuild)

→ 즉, **StatefulWidget = 상태 변화 감지 + UI 재빌드 트리거 구조**

---

# 정리 요약

| 개념                    | 핵심 포인트                                |
| ----------------------- | ------------------------------------------ |
| **Expanded**            | 행(Row) 또는 열(Column)의 남은 공간을 채움 |
| **Random**              | 난수(int, double, bool) 생성               |
| **StatelessWidget**     | 상태 없음, 고정된 UI                       |
| **StatefulWidget**      | 상태 변화 감지 및 UI 재빌드                |
| **setState()**          | 상태 변경 및 화면 갱신 요청                |
| **생명주기(Lifecycle)** | Compile → Build → Runtime 순서             |
